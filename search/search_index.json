{"config":{"lang":["en","es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udee1\ufe0f StatGuard","text":"<p>StatGuard is a robust statistics suite for PHP. It helps you summarize data with outliers without bias and compare classic vs robust results with a clear verdict.</p> <p>Info</p> <p>Includes R-compatible quantiles, robust estimators (Huber, MAD, IQR), and audit-ready exports.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Install via Composer:</p> <pre><code>composer require cjuol/statguard\n</code></pre> <p>Minimal example:</p> <pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$stats = new RobustStats();\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1000];\n\n$mean = $stats-&gt;getMean($data);\n$huber = $stats-&gt;getHuberMean($data);\n</code></pre> <p>If you want a full workflow, follow the Getting started guide and the tutorials.</p>"},{"location":"#what-you-can-do-with-statguard","title":"What you can do with StatGuard","text":"<ul> <li>Detect outlier bias with <code>StatsComparator</code>.</li> <li>Generate robust reports with <code>RobustStats</code>.</li> <li>Replicate R quantiles (types 1-9).</li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Getting started: installation and first result.</li> <li>Tutorials: recipes for real cases.</li> <li>Concepts: simple foundations before theory.</li> </ul> <p>Built with \u2764\ufe0f by cjuol.</p>"},{"location":"api-reference/","title":"API reference","text":"<p>The API generated with phpDocumentor is available in the menu under API. Use this page as a quick map of classes and minimal examples.</p> <p>Info</p> <p>If you run the site locally, open the API section to browse namespaces, classes, and methods.</p>"},{"location":"api-reference/#class-map","title":"Class map","text":"<ul> <li><code>ClassicStats</code>: classic statistics (mean, deviation, variance, outliers).</li> <li><code>RobustStats</code>: robust statistics (Huber, MAD, IQR, robust CV).</li> <li><code>QuantileEngine</code>: R-compatible quantiles types 1-9.</li> <li><code>CentralTendencyEngine</code>: median, Huber, and robust means.</li> <li><code>StatsComparator</code>: bias verdict between classic and robust.</li> </ul>"},{"location":"api-reference/#minimal-examples","title":"Minimal examples","text":""},{"location":"api-reference/#classicstats","title":"ClassicStats","text":"<pre><code>use Cjuol\\StatGuard\\ClassicStats;\n\n$classic = new ClassicStats();\n$data = [1, 2, 3, 4, 5];\n\n$mean = $classic-&gt;getMean($data);\n$summary = $classic-&gt;getSummary($data);\n</code></pre>"},{"location":"api-reference/#robuststats","title":"RobustStats","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$robust = new RobustStats();\n$data = [1, 2, 3, 4, 5, 1000];\n\n$huber = $robust-&gt;getHuberMean($data);\n$iqr = $robust-&gt;getIqr($data, RobustStats::TYPE_R_DEFAULT);\n</code></pre>"},{"location":"api-reference/#quantileengine","title":"QuantileEngine","text":"<pre><code>use Cjuol\\StatGuard\\QuantileEngine;\n\n$engine = new QuantileEngine();\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n$q7 = $engine-&gt;quantile($data, 0.75, 7);\n</code></pre>"},{"location":"api-reference/#statscomparator","title":"StatsComparator","text":"<pre><code>use Cjuol\\StatGuard\\StatsComparator;\n\n$comparator = new StatsComparator();\n$data = [10, 12, 11, 15, 10, 1000];\n\n$analysis = $comparator-&gt;analyze($data);\necho $analysis['verdict'];\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#methodology","title":"Methodology","text":"<ul> <li>Dataset: 100,000 pseudo-random floats (fixed seed).</li> <li>Environment: local execution with PHP 8.x and <code>tests/BenchmarkStatGuard.php</code>.</li> <li>Comparisons: StatGuard vs MathPHP (when an equivalent exists) and numeric parity with R.</li> <li>R uses <code>system.time()</code> and only measures computation (CSV load excluded).</li> </ul> <p>To generate and update the Markdown table:</p> <pre><code>php tests/BenchmarkStatGuard.php report\n</code></pre>"},{"location":"benchmarks/#scientific-parity-vs-r","title":"Scientific parity (vs R)","text":"<p>StatGuard replicates the 9 R quantile types and compares results against R. The reference values in the table allow comparing numeric output and timing. The Status column shows \u2705 when the absolute difference between StatGuard and R is smaller than 0.0001.</p> Method StatGuard ms StatGuard value MathPHP ms MathPHP value R ms R value Status Median 15.23 499.249 71.69 499.249 1.00 499.249 \u2705 Quantile Type 1 (p=0.75) 14.79 747.736 14.69 747.7385 1.00 747.736 \u2705 Quantile Type 2 (p=0.75) 14.36 747.741 15.37 747.7385 1.00 747.741 \u2705 Quantile Type 3 (p=0.75) 14.81 747.736 15.99 747.7385 2.00 747.736 \u2705 Quantile Type 4 (p=0.75) 14.75 747.736 15.02 747.7385 1.00 747.736 \u2705 Quantile Type 5 (p=0.75) 13.99 747.741 14.72 747.7385 1.00 747.741 \u2705 Quantile Type 6 (p=0.75) 13.67 747.7435 14.42 747.7385 1.00 747.7435 \u2705 Quantile Type 7 (p=0.75) 14.03 747.7385 15.12 747.7385 1.00 747.7385 \u2705 Quantile Type 8 (p=0.75) 13.75 747.741833 15.03 747.7385 2.00 747.7418 \u2705 Quantile Type 9 (p=0.75) 14.10 747.741625 15.15 747.7385 2.00 747.7416 \u2705 Huber mean 33.00 499.174389 37.83 499.243589 8.00 499.18 \u274c <p>Info</p> <p>The table is updated automatically with <code>php tests/BenchmarkStatGuard.php report</code>.</p>"},{"location":"benchmarks/#performance-vs-mathphp","title":"Performance (vs MathPHP)","text":"<p>StatGuard stays competitive on classic operations and outperforms MathPHP in robust statistics. The most representative benchmarks show a clear advantage in median and Huber.</p> <pre><code>xychart-beta\n    title \"Median and Huber Mean (100k)\"\n    x-axis [\"StatGuard Median\",\"MathPHP Median\",\"StatGuard Huber\",\"MathPHP Huber\"]\n    y-axis \"ms\" 0 --&gt; 820\n    bar [15.8, 76.5, 34.8, 788.7]\n</code></pre>"},{"location":"benchmarks/#conclusions","title":"Conclusions","text":"<p>StatGuard is the only PHP library that guarantees parity with the 9 R quantile types and delivers better performance than MathPHP in critical robust statistics operations.</p> <p>Built with \u2764\ufe0f by cjuol.</p>"},{"location":"concepts/","title":"Concepts (plain language)","text":"<p>These ideas help you pick the right statistic without heavy theory.</p>"},{"location":"concepts/#mean-vs-median-vs-huber","title":"Mean vs median vs Huber","text":"<p>Think of 6 measurements and one big error:</p> <pre><code>[10, 12, 11, 15, 10, 1000]\n</code></pre> <ul> <li>Mean: rises a lot because of 1000.</li> <li>Median: stays at the real center.</li> <li>Huber: behaves like the mean when data is clean, but \"brakes\" outliers.</li> </ul> <p>Simple rule: - Use the mean if data is clean. - Use median or Huber if there are outliers.</p>"},{"location":"concepts/#mad-and-iqr","title":"MAD and IQR","text":"<ul> <li>MAD (Median Absolute Deviation) measures dispersion around the median.</li> <li>IQR (Interquartile Range) measures the spread between 25% and 75%.</li> </ul> <p>If MAD or IQR are high, there is lots of noise or long tails.</p>"},{"location":"concepts/#r-quantiles","title":"R quantiles","text":"<p>R defines 9 ways to compute quantiles. StatGuard implements all of them.</p> <ul> <li>Type 7: R default. Good balance.</li> <li>Types 1-3: more discrete (less interpolation).</li> <li>Types 8-9: bias adjustments for certain distributions.</li> </ul> <p>If you are unsure, start with type 7.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-do-my-results-differ-from-r","title":"Why do my results differ from R","text":"<ul> <li>Verify that the quantile type is the same (1-9).</li> <li>Make sure you sort and clean the data in the same way.</li> <li>Confirm you are using the same decimals and rounding.</li> </ul>"},{"location":"faq/#what-minimum-dataset-size-do-i-need","title":"What minimum dataset size do I need","text":"<p>There is no hard minimum, but: - With fewer than 5-7 values, variance is unstable. - To detect outliers, more than 20 values are recommended.</p>"},{"location":"faq/#when-to-use-huber-vs-median","title":"When to use Huber vs median","text":"<ul> <li>Huber keeps efficiency when data is clean.</li> <li>Median is more resilient when extremes are aggressive.</li> </ul>"},{"location":"faq/#can-i-export-results-for-audits","title":"Can I export results for audits","text":"<p>Yes. Use <code>toJson()</code> or <code>toCsv()</code> in ClassicStats or RobustStats.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide takes you from zero to a first result in under 10 minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install via Composer:</p> <pre><code>composer require cjuol/statguard\n</code></pre> <p>Requirements: PHP 8.x.</p>"},{"location":"getting-started/#first-10-minutes","title":"First 10 minutes","text":"<p>Goal: compare the classic mean with a robust estimator and generate a quick report.</p> <pre><code>use Cjuol\\StatGuard\\RobustStats;\nuse Cjuol\\StatGuard\\StatsComparator;\n\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1000];\n\n$robust = new RobustStats();\n$mean = $robust-&gt;getMean($data);\n$huber = $robust-&gt;getHuberMean($data);\n\n$comparator = new StatsComparator();\n$analysis = $comparator-&gt;analyze($data);\n\nfile_put_contents('report.json', $robust-&gt;toJson($data));\n\nprint_r([\n    'mean' =&gt; $mean,\n    'huber' =&gt; $huber,\n    'verdict' =&gt; $analysis['verdict'],\n]);\n</code></pre> <p>What to expect: - The mean shifts because of the outlier. - Huber stays near the center. - The verdict flags bias from extreme values.</p>"},{"location":"getting-started/#next-step","title":"Next step","text":"<p>Go to the tutorials for full cases and recipes.</p>"},{"location":"math-basis/","title":"Mathematical basis","text":"<p>This section explains the \"why\" with a simple approach. If you want recipes, go to Tutorials. If you want full formulas, keep reading.</p>"},{"location":"math-basis/#huber-m-estimator","title":"Huber M-Estimator","text":"<p>Simple idea: the classic mean gives too much weight to extreme values. Huber keeps the center stable and applies a gradual brake to outliers.</p> <p>Quick example:</p> <pre><code>[10, 12, 11, 15, 10, 1000]\n</code></pre> <p>The mean jumps too much, but Huber stays near the center.</p> <p>Definition:</p> \\[ \\rho_k(r) = \\begin{cases} \\frac{1}{2} r^2 &amp; \\text{if } |r| \\le k \\\\ k\\left(|r| - \\frac{1}{2} k\\right) &amp; \\text{if } |r| &gt; k \\end{cases} \\] <p>Interpretation: - Near the center, it behaves like the mean (quadratic). - In the tails, it becomes linear to reduce impact.</p>"},{"location":"math-basis/#scaled-mad","title":"Scaled MAD","text":"<p>MAD measures dispersion around the median. To compare it with standard deviation, scale it as follows:</p> \\[ \\sigma_{robust} = MAD \\times 1.4826 \\] <p>This makes it comparable under normal distributions.</p>"},{"location":"math-basis/#robust-coefficient-of-variation","title":"Robust coefficient of variation","text":"<p>Instead of the mean, use the median to avoid inflating variability:</p> \\[ CV_r = \\left(\\frac{\\sigma_{robust}}{|\\tilde{x}|}\\right) \\times 100 \\]"},{"location":"math-basis/#r-quantiles-hyndman-fan","title":"R quantiles (Hyndman &amp; Fan)","text":"<p>For an ordered set \\(x_{(1)} \\le \\dots \\le x_{(n)}\\), quantiles follow rules defined by \\(p_k\\) and parameters \\((a, b)\\):</p> \\[ p_k = \\frac{k - a}{n + b} \\] <p>Linear interpolation applies between \\(x_{(j)}\\) and \\(x_{(j+1)}\\) when \\(p\\) falls between positions. StatGuard implements the 9 types used by R.</p> Type \\(p_k\\) \\(a\\) \\(b\\) Note 1 \\(k / n\\) 0 0 Inverse of the empirical CDF (discontinuous). 2 \\(k / n\\) 0 0 Averages at discontinuities. 3 \\((k - 0.5) / n\\) -0.5 0 Nearest order statistic. 4 \\(k / n\\) 0 1 Linear interpolation of CDF. 5 \\((k - 0.5) / n\\) 0.5 0.5 Hazen (1914). 6 \\(k / (n + 1)\\) 0 1 Weibull (1939). 7 \\((k - 1) / (n - 1)\\) 1 1 R default, mode of \\(F(x)\\). 8 \\((k - 1/3) / (n + 1/3)\\) 1/3 1/3 Median-unbiased. 9 \\((k - 3/8) / (n + 1/4)\\) 3/8 3/8 Normal-unbiased. <p>Success</p> <p>If you are unsure, type 7 is the default behavior in R.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Short recipes for common tasks.</p>"},{"location":"tutorials/#1-detect-outlier-bias","title":"1) Detect outlier bias","text":"<pre><code>use Cjuol\\StatGuard\\StatsComparator;\n\n$data = [10, 12, 11, 15, 10, 1000];\n\n$comparator = new StatsComparator();\n$analysis = $comparator-&gt;analyze($data);\n\necho $analysis['verdict'];\n</code></pre> <p>Quick interpretation: - If the verdict warns about bias, use median or Huber. - If the verdict is stable, the classic mean is safe.</p>"},{"location":"tutorials/#2-robust-summary-for-reports","title":"2) Robust summary for reports","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$data = [10, 12, 11, 15, 10, 1000];\n\n$robust = new RobustStats();\n$summary = $robust-&gt;getSummary($data);\n\nfile_put_contents('summary.csv', $robust-&gt;toCsv($data));\nfile_put_contents('summary.json', $robust-&gt;toJson($data));\n</code></pre>"},{"location":"tutorials/#3-r-compatible-quantiles","title":"3) R-compatible quantiles","text":"<pre><code>use Cjuol\\StatGuard\\QuantileEngine;\n\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n$engine = new QuantileEngine();\n\n// Type 7 is the R default.\n$q7 = $engine-&gt;quantile($data, 0.75, 7);\n\n// Type 1 is more discrete and depends on ordering.\n$q1 = $engine-&gt;quantile($data, 0.75, 1);\n</code></pre> <p>When to pick type 7: - General exploratory analysis. - Consistency with R defaults.</p> <p>When to pick type 1: - Discrete series or counts where you do not want interpolation.</p>"},{"location":"es/","title":"\ud83d\udee1\ufe0f StatGuard: Estadistica Robusta e Integridad de Datos para PHP","text":"<p>StatGuard es una suite de analisis estadistico robusto para PHP enfocada en precision cientifica e integridad de datos. Compara estadistica clasica contra estadistica robusta para detectar sesgo, ruido y anomalias de medicion de forma automatica.</p>"},{"location":"es/#por-que-statguard","title":"\u00bfPor qu\u00e9 StatGuard?","text":"<p>Los valores atipicos son inevitables en telemetria, finanzas, deporte y laboratorios. Un solo valor extremo puede arrastrar la media aritmetica lejos de la masa central y sesgar las decisiones. StatGuard ofrece estimadores robustos (mediana, MAD, medias recortadas y winsorizadas, estimador M de Huber) que se mantienen estables bajo contaminacion, permitiendo confiar en los resumenes aun con datos ruidosos.</p>"},{"location":"es/#destacados","title":"Destacados","text":"<ul> <li>ClassicStats: Implementacion completa de estadistica descriptiva clasica.</li> <li>StatsComparator: Nucleo de analisis que evalua la fidelidad de los datos y emite un veredicto.</li> <li>ExportableTrait: Exportacion CSV y JSON para cada clase estadistica.</li> <li>Traits + Interfaces: Validacion integrada y arquitectura extensible.</li> <li>Motores independientes: <code>QuantileEngine</code> y <code>CentralTendencyEngine</code> mantienen la matematica central aislada y reutilizable.</li> <li>Paridad con R: Cuantiles y medias robustas validadas contra resultados de R.</li> </ul>"},{"location":"es/#caracteristicas","title":"Caracteristicas","text":"<ul> <li>9 tipos de cuantiles compatibles con R (Hyndman &amp; Fan 1-9).</li> <li>Medias robustas: Huber, winsorizada y recortada.</li> </ul>"},{"location":"es/#instalacion","title":"Instalacion","text":"<p>Instalacion via Composer:</p> <pre><code>composer require cjuol/statguard\n</code></pre>"},{"location":"es/#uso","title":"Uso","text":""},{"location":"es/#estimadores-robustos-inicio-rapido","title":"Estimadores Robustos (Inicio Rapido)","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$stats = new RobustStats();\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1000];\n\n$huber = $stats-&gt;getHuberMean($data);\n$winsorized = $stats-&gt;getWinsorizedMean($data, 0.1);\n$iqr = $stats-&gt;getIqr($data, RobustStats::TYPE_R_DEFAULT);\n</code></pre> <p>Los estimadores robustos se mantienen estables ante valores atipicos extremos:</p> Metrica Resultado Comentario Media aritmetica 95.9091 Sesgada por el valor atipico Media de Huber 6.0982 Cerca de la masa central"},{"location":"es/#ejemplo-media-de-huber","title":"Ejemplo: Media de Huber","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$robust = new RobustStats();\n$data = [10, 12, 11, 15, 10, 1000];\n\n$huber = $robust-&gt;getHuberMean($data, 1.345, 50, 0.001);\n</code></pre>"},{"location":"es/#ejemplo-media-winsorizada-tipo-de-cuantil-compatible-con-r","title":"Ejemplo: Media Winsorizada (Tipo de Cuantil Compatible con R)","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$robust = new RobustStats();\n$data = [10, 12, 11, 15, 10, 1000];\n\n// El tipo 7 coincide con el quantile() por defecto de R.\n$winsorized = $robust-&gt;getWinsorizedMean($data, 0.1, 7);\n</code></pre>"},{"location":"es/#comparator-deteccion-de-sesgo","title":"Comparator (Deteccion de Sesgo)","text":"<pre><code>use Cjuol\\StatGuard\\StatsComparator;\n\n$comparator = new StatsComparator();\n$data = [10, 12, 11, 15, 10, 1000];\n\n$analysis = $comparator-&gt;analyze($data);\n\necho $analysis['verdict'];\n// ALERTA: Los datos estan muy influidos por valores atipicos. Use metricas robustas.\n</code></pre>"},{"location":"es/#exportacion-instantanea","title":"Exportacion Instantanea","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$robust = new RobustStats();\n\nfile_put_contents('report.csv', $robust-&gt;toCsv($data));\necho $robust-&gt;toJson($data);\n</code></pre>"},{"location":"es/#claves-de-resumen-clasico-vs-robusto","title":"Claves de Resumen (Clasico vs Robusto)","text":"<p>Claves clasicas:</p> <pre><code>[\n    'mean',\n    'median',\n    'stdDev',\n    'sampleVariance',\n    'cv',\n    'outliersZScore',\n    'count'\n]\n</code></pre> <p>Claves robustas:</p> <pre><code>[\n    'mean',\n    'median',\n    'robustDeviation',\n    'robustVariance',\n    'robustCv',\n    'iqr',\n    'mad',\n    'outliers',\n    'confidenceIntervals',\n    'count'\n]\n</code></pre>"},{"location":"es/#comparativa-de-metricas","title":"Comparativa de Metricas","text":"Metrica ClassicStats RobustStats Impacto del Valor Atipico Centro Media Mediana Alto en clasico Dispersion Desviacion estandar MAD (escalado) Extremo en clasico Variabilidad CV% CV% robusto Muy alto en clasico Exportable \u2705 Si \u2705 Si -"},{"location":"es/#tipos-de-cuantil-r-1-9","title":"Tipos de Cuantil R (1-9)","text":"<p>StatGuard replica las definiciones de cuantiles de R v4.x. La tabla resume los nueve tipos de Hyndman &amp; Fan (1996) soportados por <code>quantile()</code>.</p> Tipo \\(p_k\\) \\(a\\) \\(b\\) Notas 1 \\(k / n\\) 0 0 Inversa de la CDF empirica (discontinua). 2 \\(k / n\\) 0 0 Promediado en discontinuidades. 3 \\((k - 0.5) / n\\) -0.5 0 Estadistico de orden mas cercano. 4 \\(k / n\\) 0 1 Interpolacion lineal de la CDF. 5 \\((k - 0.5) / n\\) 0.5 0.5 Hazen (1914). 6 \\(k / (n + 1)\\) 0 1 Weibull (1939). 7 \\((k - 1) / (n - 1)\\) 1 1 Por defecto de R, modo de \\(F(x)\\). 8 \\((k - 1/3) / (n + 1/3)\\) 1/3 1/3 Mediana-no-sesgado. 9 \\((k - 3/8) / (n + 1/4)\\) 3/8 3/8 Normal-no-sesgado."},{"location":"es/#metodos-implementados","title":"Metodos Implementados","text":""},{"location":"es/#classicstats","title":"ClassicStats","text":"<ul> <li><code>getMean(array $data): float</code></li> <li><code>getMedian(array $data): float</code></li> <li><code>getDeviation(array $data): float</code></li> <li><code>getStandardDeviation(array $data): float</code></li> <li><code>getCoefficientOfVariation(array $data): float</code></li> <li><code>getSampleVariance(array $data): float</code></li> <li><code>getPopulationVariance(array $data): float</code></li> <li><code>getOutliers(array $data): array</code></li> <li><code>getSummary(array $data, bool $sort = true, int $decimals = 2): array</code></li> <li><code>toJson(array $data, int $options = JSON_PRETTY_PRINT): string</code></li> <li><code>toCsv(array $data, string $delimiter = \",\"): string</code></li> </ul>"},{"location":"es/#robuststats","title":"RobustStats","text":"<ul> <li><code>getMean(array $data): float</code></li> <li><code>getMedian(array $data): float</code></li> <li><code>getDeviation(array $data): float</code></li> <li><code>getCoefficientOfVariation(array $data): float</code></li> <li><code>getRobustDeviation(array $data): float</code></li> <li><code>getRobustCv(array $data): float</code></li> <li><code>getRobustVariance(array $data): float</code></li> <li><code>getIqr(array $data): float</code></li> <li><code>getMad(array $data): float</code></li> <li><code>getOutliers(array $data): array</code></li> <li><code>getConfidenceIntervals(array $data): array</code></li> <li><code>getTrimmedMean(array $data, float $trimPercentage = 0.1): float</code></li> <li><code>getWinsorizedMean(array $data, float $trimPercentage = 0.1, int $type = 7): float</code></li> <li><code>getHuberMean(array $data, float $k = 1.345, int $maxIterations = 50, float $tolerance = 0.001): float</code></li> <li><code>getSummary(array $data, bool $sort = true, int $decimals = 2): array</code></li> <li><code>toJson(array $data, int $options = JSON_PRETTY_PRINT): string</code></li> <li><code>toCsv(array $data, string $delimiter = \",\"): string</code></li> </ul>"},{"location":"es/#statscomparator","title":"StatsComparator","text":"<ul> <li><code>__construct(?RobustStats $robust = null, ?ClassicStats $classic = null)</code></li> <li><code>analyze(array $data, int $decimals = 2): array</code></li> </ul>"},{"location":"es/#base-matematica","title":"Base Matematica","text":""},{"location":"es/#desviacion-robusta-escalada","title":"Desviacion Robusta Escalada","text":"<p>Para comparaciones justas, la MAD se escala para ser comparable con la desviacion estandar bajo distribuciones normales:</p> \\[\\sigma_{robust} = MAD \\times 1.4826\\]"},{"location":"es/#coeficiente-de-variacion-robusta-cv_r","title":"Coeficiente de Variacion Robusta (\\(CV_r\\))","text":"<p>Se calcula sobre la mediana para evitar que un valor extremo infle la volatilidad:</p> \\[CV_r = \\left( \\frac{\\sigma_{robust}}{|\\tilde{x}|} \\right) \\times 100\\]"},{"location":"es/api-reference/","title":"Referencia de API","text":"<p>La API generada con phpDocumentor esta disponible en el menu bajo el enlace API. Usa esta pagina como mapa rapido de clases y ejemplos minimos.</p> <p>Info</p> <p>Si ejecutas el sitio localmente, abre la seccion API para navegar por namespaces, clases y metodos.</p>"},{"location":"es/api-reference/#mapa-de-clases","title":"Mapa de clases","text":"<ul> <li><code>ClassicStats</code>: estadistica clasica (media, desviacion, varianza, outliers).</li> <li><code>RobustStats</code>: estadistica robusta (Huber, MAD, IQR, robust CV).</li> <li><code>QuantileEngine</code>: cuantiles tipo 1-9 compatibles con R.</li> <li><code>CentralTendencyEngine</code>: mediana, Huber y medias robustas.</li> <li><code>StatsComparator</code>: veredicto de sesgo entre clasico y robusto.</li> </ul>"},{"location":"es/api-reference/#ejemplos-minimos","title":"Ejemplos minimos","text":""},{"location":"es/benchmarks/#metodologia","title":"Metodologia","text":"<ul> <li>Dataset: 100,000 floats pseudoaleatorios (seed fija).</li> <li>Entorno: ejecucion local con PHP 8.x y el script <code>tests/BenchmarkStatGuard.php</code>.</li> <li>Comparativas: StatGuard vs MathPHP (cuando existe equivalente) y paridad numerica con R.</li> <li>R usa <code>system.time()</code> y solo mide computo (se excluye la carga del CSV).</li> </ul> <p>Para generar y actualizar la tabla en Markdown:</p> <pre><code>php tests/BenchmarkStatGuard.php report\n</code></pre>"},{"location":"es/benchmarks/#paridad-cientifica-vs-r","title":"Paridad Cientifica (vs R)","text":"<p>StatGuard replica los 9 tipos de cuantiles de R y contrasta sus resultados con el motor base de R. Los valores de referencia en la tabla permiten comparar salida numerica y tiempos. La columna Status marca \u2705 cuando la diferencia absoluta entre StatGuard y R es menor a 0.0001.</p> Method StatGuard ms StatGuard value MathPHP ms MathPHP value R ms R value Status Median 15.23 499.249 71.69 499.249 1.00 499.249 \u2705 Quantile Type 1 (p=0.75) 14.79 747.736 14.69 747.7385 1.00 747.736 \u2705 Quantile Type 2 (p=0.75) 14.36 747.741 15.37 747.7385 1.00 747.741 \u2705 Quantile Type 3 (p=0.75) 14.81 747.736 15.99 747.7385 2.00 747.736 \u2705 Quantile Type 4 (p=0.75) 14.75 747.736 15.02 747.7385 1.00 747.736 \u2705 Quantile Type 5 (p=0.75) 13.99 747.741 14.72 747.7385 1.00 747.741 \u2705 Quantile Type 6 (p=0.75) 13.67 747.7435 14.42 747.7385 1.00 747.7435 \u2705 Quantile Type 7 (p=0.75) 14.03 747.7385 15.12 747.7385 1.00 747.7385 \u2705 Quantile Type 8 (p=0.75) 13.75 747.741833 15.03 747.7385 2.00 747.7418 \u2705 Quantile Type 9 (p=0.75) 14.10 747.741625 15.15 747.7385 2.00 747.7416 \u2705 Huber mean 33.00 499.174389 37.83 499.243589 8.00 499.18 \u274c <p>Info</p> <p>La tabla se actualiza automaticamente con <code>php tests/BenchmarkStatGuard.php report</code>.</p>"},{"location":"es/benchmarks/#rendimiento-vs-mathphp","title":"Rendimiento (vs MathPHP)","text":"<p>StatGuard mantiene competitividad en operaciones clasicas y supera a MathPHP en estadistica robusta. Los benchmarks mas representativos muestran una ventaja clara en mediana y Huber.</p> <pre><code>xychart-beta\n    title \"Median and Huber Mean (100k)\"\n    x-axis [\"StatGuard Median\",\"MathPHP Median\",\"StatGuard Huber\",\"MathPHP Huber\"]\n    y-axis \"ms\" 0 --&gt; 820\n    bar [15.8, 76.5, 34.8, 788.7]\n</code></pre>"},{"location":"es/benchmarks/#conclusiones","title":"Conclusiones","text":"<p>StatGuard es la unica libreria PHP que garantiza paridad con los 9 tipos de cuantiles de R y entrega un rendimiento superior a MathPHP en operaciones criticas de estadistica robusta.</p> <p>Built with \u2764\ufe0f by cjuol.</p>"},{"location":"es/concepts/","title":"Conceptos (para dummys)","text":"<p>Estas ideas te ayudan a escoger la estadistica correcta sin entrar en teoria pesada.</p>"},{"location":"es/concepts/#media-vs-mediana-vs-huber","title":"Media vs mediana vs Huber","text":"<p>Piensa en 6 mediciones y un error grande:</p> <pre><code>[10, 12, 11, 15, 10, 1000]\n</code></pre> <ul> <li>Media: sube mucho por el 1000.</li> <li>Mediana: se queda en el centro real.</li> <li>Huber: se parece a la media cuando todo esta limpio, pero \"frena\" outliers.</li> </ul> <p>Regla simple: - Usa media si los datos son limpios. - Usa mediana o Huber si hay outliers.</p>"},{"location":"es/concepts/#mad-e-iqr","title":"MAD e IQR","text":"<ul> <li>MAD (Median Absolute Deviation) mide dispersion alrededor de la mediana.</li> <li>IQR (Interquartile Range) mide el rango entre el 25% y 75%.</li> </ul> <p>Si el MAD o el IQR son altos, hay mucho ruido o colas largas.</p>"},{"location":"es/concepts/#cuantiles-de-r","title":"Cuantiles de R","text":"<p>R define 9 formas de calcular cuantiles. StatGuard implementa todas.</p> <ul> <li>Tipo 7: default de R. Buen equilibrio.</li> <li>Tipos 1-3: mas discretos (menos interpolacion).</li> <li>Tipos 8-9: ajustes de sesgo para ciertas distribuciones.</li> </ul> <p>Si no sabes cual usar, empieza por tipo 7.</p>"},{"location":"es/faq/#por-que-mis-resultados-difieren-de-r","title":"Por que mis resultados difieren de R","text":"<ul> <li>Verifica que el tipo de cuantil sea el mismo (1-9).</li> <li>Asegurate de ordenar y limpiar los datos igual.</li> <li>Confirma que estas usando los mismos decimales y redondeo.</li> </ul>"},{"location":"es/faq/#que-tamanio-minimo-de-dataset-necesito","title":"Que tamanio minimo de dataset necesito","text":"<p>No hay minimo tecnico, pero: - Con menos de 5-7 valores, la varianza es poco estable. - Para detectar outliers, se recomiendan mas de 20 valores.</p>"},{"location":"es/faq/#cuando-usar-huber-vs-mediana","title":"Cuando usar Huber vs mediana","text":"<ul> <li>Huber conserva eficiencia cuando los datos son limpios.</li> <li>Mediana es mas resistente si hay extremos muy agresivos.</li> </ul>"},{"location":"es/faq/#puedo-exportar-resultados-para-auditoria","title":"Puedo exportar resultados para auditoria","text":"<p>Si, usa <code>toJson()</code> o <code>toCsv()</code> en ClassicStats o RobustStats.</p>"},{"location":"es/getting-started/","title":"Guia de inicio","text":"<p>Esta guia te lleva de cero a un primer resultado en menos de 10 minutos.</p>"},{"location":"es/getting-started/#instalacion","title":"Instalacion","text":"<p>Instala via Composer:</p> <pre><code>composer require cjuol/statguard\n</code></pre> <p>Requisitos: PHP 8.x.</p>"},{"location":"es/getting-started/#primeros-10-minutos","title":"Primeros 10 minutos","text":"<p>Objetivo: comparar la media clasica con un estimador robusto y generar un reporte rapido.</p> <pre><code>use Cjuol\\StatGuard\\RobustStats;\nuse Cjuol\\StatGuard\\StatsComparator;\n\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1000];\n\n$robust = new RobustStats();\n$mean = $robust-&gt;getMean($data);\n$huber = $robust-&gt;getHuberMean($data);\n\n$comparator = new StatsComparator();\n$analysis = $comparator-&gt;analyze($data);\n\nfile_put_contents('report.json', $robust-&gt;toJson($data));\n\nprint_r([\n    'mean' =&gt; $mean,\n    'huber' =&gt; $huber,\n    'verdict' =&gt; $analysis['verdict'],\n]);\n</code></pre> <p>Que esperar: - La media se desplaza por el outlier. - Huber se mantiene cerca del centro. - El veredicto indica sesgo por valores extremos.</p>"},{"location":"es/getting-started/#siguiente-paso","title":"Siguiente paso","text":"<p>Pasa a los tutoriales para ver casos completos y recetas.</p>"},{"location":"es/math-basis/","title":"Fundamentos matematicos","text":"<p>Esta seccion explica el \"por que\" con un enfoque simple. Si quieres recetas, ve a Tutoriales. Si buscas formulas completas, continua aqui.</p>"},{"location":"es/math-basis/#huber-m-estimator","title":"Huber M-Estimator","text":"<p>Idea simple: la media clasica da demasiado peso a valores extremos. Huber mantiene el centro estable y aplica un freno gradual a los outliers.</p> <p>Ejemplo rapido:</p> <pre><code>[10, 12, 11, 15, 10, 1000]\n</code></pre> <p>La media sube demasiado, pero Huber se mantiene cerca del centro.</p> <p>Definicion:</p> \\[ \\rho_k(r) = \\begin{cases} \\frac{1}{2} r^2 &amp; \\text{si } |r| \\le k \\\\ k\\left(|r| - \\frac{1}{2} k\\right) &amp; \\text{si } |r| &gt; k \\end{cases} \\] <p>Interpretacion: - Cerca del centro, se comporta como la media (cuadratica). - En las colas, se vuelve lineal para reducir el impacto.</p>"},{"location":"es/math-basis/#mad-escalado","title":"MAD escalado","text":"<p>MAD mide dispersion alrededor de la mediana. Para comparar con desviacion estandar, se escala asi:</p> \\[ \\sigma_{robust} = MAD \\times 1.4826 \\] <p>Esto lo hace comparable bajo distribuciones normales.</p>"},{"location":"es/math-basis/#coeficiente-de-variacion-robusto","title":"Coeficiente de variacion robusto","text":"<p>En lugar de la media, se usa la mediana para evitar inflar la variabilidad:</p> \\[ CV_r = \\left(\\frac{\\sigma_{robust}}{|\\tilde{x}|}\\right) \\times 100 \\]"},{"location":"es/math-basis/#cuantiles-de-r-hyndman-fan","title":"Cuantiles de R (Hyndman &amp; Fan)","text":"<p>Para un conjunto ordenado \\(x_{(1)} \\le \\dots \\le x_{(n)}\\), los cuantiles siguen reglas definidas por \\(p_k\\) y por los parametros \\((a, b)\\):</p> \\[ p_k = \\frac{k - a}{n + b} \\] <p>La interpolacion lineal se aplica entre \\(x_{(j)}\\) y \\(x_{(j+1)}\\) cuando \\(p\\) cae entre posiciones. StatGuard implementa los 9 tipos usados por R.</p> Tipo \\(p_k\\) \\(a\\) \\(b\\) Nota 1 \\(k / n\\) 0 0 Inversa de la CDF empirica (discontinua). 2 \\(k / n\\) 0 0 Promedia en discontinuidades. 3 \\((k - 0.5) / n\\) -0.5 0 Estadistico de orden mas cercano. 4 \\(k / n\\) 0 1 Interpolacion lineal de CDF. 5 \\((k - 0.5) / n\\) 0.5 0.5 Hazen (1914). 6 \\(k / (n + 1)\\) 0 1 Weibull (1939). 7 \\((k - 1) / (n - 1)\\) 1 1 Default de R, modo de \\(F(x)\\). 8 \\((k - 1/3) / (n + 1/3)\\) 1/3 1/3 Mediana-no-sesgada. 9 \\((k - 3/8) / (n + 1/4)\\) 3/8 3/8 Normal-no-sesgada. <p>Success</p> <p>Si no sabes cual usar, el tipo 7 es el comportamiento por defecto de R.</p>"},{"location":"es/tutorials/","title":"Tutoriales","text":"<p>Recetas cortas para tareas comunes.</p>"},{"location":"es/tutorials/#1-detectar-sesgo-por-outliers","title":"1) Detectar sesgo por outliers","text":"<pre><code>use Cjuol\\StatGuard\\StatsComparator;\n\n$data = [10, 12, 11, 15, 10, 1000];\n\n$comparator = new StatsComparator();\n$analysis = $comparator-&gt;analyze($data);\n\necho $analysis['verdict'];\n</code></pre> <p>Interpretacion rapida: - Si el veredicto alerta sesgo, usa medianas o Huber. - Si el veredicto es estable, la media clasica es segura.</p>"},{"location":"es/tutorials/#2-resumen-robusto-para-reportes","title":"2) Resumen robusto para reportes","text":"<pre><code>use Cjuol\\StatGuard\\RobustStats;\n\n$data = [10, 12, 11, 15, 10, 1000];\n\n$robust = new RobustStats();\n$summary = $robust-&gt;getSummary($data);\n\nfile_put_contents('summary.csv', $robust-&gt;toCsv($data));\nfile_put_contents('summary.json', $robust-&gt;toJson($data));\n</code></pre>"},{"location":"es/tutorials/#3-cuantiles-compatibles-con-r","title":"3) Cuantiles compatibles con R","text":"<pre><code>use Cjuol\\StatGuard\\QuantileEngine;\n\n$data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n$engine = new QuantileEngine();\n\n// Type 7 es el default de R.\n$q7 = $engine-&gt;quantile($data, 0.75, 7);\n\n// Type 1 es mas discreto y depende del orden.\n$q1 = $engine-&gt;quantile($data, 0.75, 1);\n</code></pre> <p>Cuando elegir tipo 7: - Analisis exploratorio general. - Consistencia con R por defecto.</p> <p>Cuando elegir tipo 1: - Series discretas o conteos donde no deseas interpolacion.</p>"}]}